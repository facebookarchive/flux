"use strict";(self.webpackChunkflux_website=self.webpackChunkflux_website||[]).push([[583],{4505:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return r},metadata:function(){return c},toc:function(){return u}});var n=a(3117),o=a(102),i=(a(8771),a(3905)),s=["components"],r={id:"flux-utils",title:"Flux Utils"},l=void 0,c={unversionedId:"flux-utils",id:"flux-utils",title:"Flux Utils",description:"Flux Utils is a set of basic utility classes to help get you started with Flux. These base classes are a solid foundation for a simple Flux application, but they are not a feature-complete framework that will handle all use cases. There are many other great Flux frameworks out there if these utilities do not fulfill your needs.",source:"@site/../docs/Flux-Utils.md",sourceDirName:".",slug:"/flux-utils",permalink:"/flux/docs/flux-utils",draft:!1,editUrl:"https://github.com/facebook/flux/edit/master/docs/../docs/Flux-Utils.md",tags:[],version:"current",lastUpdatedBy:"Yangshun Tay",lastUpdatedAt:1654233097,formattedLastUpdatedAt:"Jun 3, 2022",frontMatter:{id:"flux-utils",title:"Flux Utils"},sidebar:"docs",previous:{title:"Dispatcher",permalink:"/flux/docs/dispatcher"},next:{title:"Videos",permalink:"/flux/docs/videos"}},d={},u=[{value:"Usage",id:"usage",level:2},{value:"Best practices",id:"best-practices",level:2},{value:"Stores",id:"stores",level:3},{value:"Actions",id:"actions",level:3},{value:"Containers",id:"containers",level:3},{value:"Views",id:"views",level:3},{value:"API",id:"api",level:2},{value:"<code>Store</code>",id:"store",level:3},{value:"<code>constructor(dispatcher: Dispatcher)</code>",id:"constructordispatcher-dispatcher",level:4},{value:"<code>addListener(callback: Function): {remove: Function}</code>",id:"addlistenercallback-function-remove-function",level:4},{value:"<code>getDispatcher(): Dispatcher</code>",id:"getdispatcher-dispatcher",level:4},{value:"<code>getDispatchToken(): DispatchToken</code>",id:"getdispatchtoken-dispatchtoken",level:4},{value:"<code>hasChanged(): boolean</code>",id:"haschanged-boolean",level:4},{value:"<code>__emitChange(): void</code>",id:"__emitchange-void",level:4},{value:"<code>onDispatch(payload: Object): void</code>",id:"ondispatchpayload-object-void",level:4},{value:"<code>ReduceStore&lt;T&gt;</code>",id:"reducestoret",level:3},{value:"<code>getState(): T</code>",id:"getstate-t",level:4},{value:"<code>getInitialState(): T</code>",id:"getinitialstate-t",level:4},{value:"<code>reduce(state: T, action: Object): T</code>",id:"reducestate-t-action-object-t",level:4},{value:"<code>areEqual(one: T, two: T): boolean</code>",id:"areequalone-t-two-t-boolean",level:4},{value:"Doesn&#39;t Need to Emit a Change",id:"doesnt-need-to-emit-a-change",level:4},{value:"<code>Container</code>",id:"container",level:3},{value:"<code>create(base: ReactClass, options: ?Object): ReactClass</code>",id:"createbase-reactclass-options-object-reactclass",level:4},{value:"Using Flux with React Hooks",id:"using-flux-with-react-hooks",level:2},{value:"Existing Projects with <code>Store</code>/<code>ReduceStore</code>",id:"existing-projects-with-storereducestore",level:2}],h={toc:u},p="wrapper";function m(e){var t=e.components,a=(0,o.Z)(e,s);return(0,i.kt)(p,(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Flux Utils is a set of basic utility classes to help get you started with Flux. These base classes are a solid foundation for a simple Flux application, but they are ",(0,i.kt)("strong",{parentName:"p"},"not")," a feature-complete framework that will handle all use cases. There are many other great Flux frameworks out there if these utilities do not fulfill your needs."),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("p",null,"There are three main classes exposed in Flux Utils:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Store")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"ReduceStore")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Container"))),(0,i.kt)("p",null,"These base classes can be imported from ",(0,i.kt)("inlineCode",{parentName:"p"},"flux/utils")," like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {ReduceStore} from 'flux/utils';\n\nclass CounterStore extends ReduceStore<number> {\n  getInitialState(): number {\n    return 0;\n  }\n\n  reduce(state: number, action: Object): number {\n    switch (action.type) {\n      case 'increment':\n        return state + 1;\n\n      case 'square':\n        return state * state;\n\n      default:\n        return state;\n    }\n  }\n}\n")),(0,i.kt)("h2",{id:"best-practices"},"Best practices"),(0,i.kt)("p",null,"There are some best practices we try to follow when using these classes:"),(0,i.kt)("h3",{id:"stores"},"Stores"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Cache data"),(0,i.kt)("li",{parentName:"ul"},"Expose public getters to access data (never have public setters)"),(0,i.kt)("li",{parentName:"ul"},"Respond to specific actions from the dispatcher"),(0,i.kt)("li",{parentName:"ul"},"Always emit a change when their data changes"),(0,i.kt)("li",{parentName:"ul"},"Only emit changes during a dispatch")),(0,i.kt)("h3",{id:"actions"},"Actions"),(0,i.kt)("p",null,"Describe a user's action, are not setters. (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"select-page")," not ",(0,i.kt)("inlineCode",{parentName:"p"},"set-page-id"),")"),(0,i.kt)("h3",{id:"containers"},"Containers"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Are React components that control a view"),(0,i.kt)("li",{parentName:"ul"},"Primary job is to gather information from stores and save it in their state"),(0,i.kt)("li",{parentName:"ul"},"Have no ",(0,i.kt)("inlineCode",{parentName:"li"},"props")," and no UI logic")),(0,i.kt)("h3",{id:"views"},"Views"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Are React components that are controlled by a container"),(0,i.kt)("li",{parentName:"ul"},"Have all of the UI and rendering logic"),(0,i.kt)("li",{parentName:"ul"},"Receive all information and callbacks as props")),(0,i.kt)("h2",{id:"api"},"API"),(0,i.kt)("h3",{id:"store"},(0,i.kt)("inlineCode",{parentName:"h3"},"Store")),(0,i.kt)("h4",{id:"constructordispatcher-dispatcher"},(0,i.kt)("inlineCode",{parentName:"h4"},"constructor(dispatcher: Dispatcher)")),(0,i.kt)("p",null,"Constructs and registers an instance of this store with the given dispatcher."),(0,i.kt)("h4",{id:"addlistenercallback-function-remove-function"},(0,i.kt)("inlineCode",{parentName:"h4"},"addListener(callback: Function): {remove: Function}")),(0,i.kt)("p",null,"Adds a listener to the store, when the store changes the given callback will be called. A token is returned that can be used to remove the listener. Calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"remove()")," function on the returned token will remove the listener."),(0,i.kt)("h4",{id:"getdispatcher-dispatcher"},(0,i.kt)("inlineCode",{parentName:"h4"},"getDispatcher(): Dispatcher")),(0,i.kt)("p",null,"Returns the dispatcher this store is registered with."),(0,i.kt)("h4",{id:"getdispatchtoken-dispatchtoken"},(0,i.kt)("inlineCode",{parentName:"h4"},"getDispatchToken(): DispatchToken")),(0,i.kt)("p",null,"Returns the dispatch token that the dispatcher recognizes this store by. Can be used to ",(0,i.kt)("inlineCode",{parentName:"p"},"waitFor()")," this store."),(0,i.kt)("h4",{id:"haschanged-boolean"},(0,i.kt)("inlineCode",{parentName:"h4"},"hasChanged(): boolean")),(0,i.kt)("p",null,"Ask if a store has changed during the current dispatch. Can only be invoked while dispatching. This can be used for constructing derived stores that depend on data from other stores."),(0,i.kt)("h4",{id:"__emitchange-void"},(0,i.kt)("inlineCode",{parentName:"h4"},"__emitChange(): void")),(0,i.kt)("p",null,"Emit an event notifying all listeners that this store has changed. This can only be invoked when dispatching. Changes are de-duplicated and resolved at the end of this store's ",(0,i.kt)("inlineCode",{parentName:"p"},"__onDispatch")," function."),(0,i.kt)("h4",{id:"ondispatchpayload-object-void"},(0,i.kt)("inlineCode",{parentName:"h4"},"onDispatch(payload: Object): void")),(0,i.kt)("p",null,"Subclasses must override this method. This is how the store receives actions from the dispatcher. All state mutation logic must be done during this method."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"reducestoret"},(0,i.kt)("inlineCode",{parentName:"h3"},"ReduceStore<T>")),(0,i.kt)("p",null,"This class extends the base ",(0,i.kt)("inlineCode",{parentName:"p"},"Store"),"."),(0,i.kt)("h4",{id:"getstate-t"},(0,i.kt)("inlineCode",{parentName:"h4"},"getState(): T")),(0,i.kt)("p",null,"Getter that exposes the entire state of this store. If your state is not immutable you should override this and not expose state directly."),(0,i.kt)("h4",{id:"getinitialstate-t"},(0,i.kt)("inlineCode",{parentName:"h4"},"getInitialState(): T")),(0,i.kt)("p",null,"Constructs the initial state for this store. This is called once during construction of the store."),(0,i.kt)("h4",{id:"reducestate-t-action-object-t"},(0,i.kt)("inlineCode",{parentName:"h4"},"reduce(state: T, action: Object): T")),(0,i.kt)("p",null,"Reduces the current state, and an action to the new state of this store. All subclasses must implement this method. This method should be pure and have no side-effects."),(0,i.kt)("h4",{id:"areequalone-t-two-t-boolean"},(0,i.kt)("inlineCode",{parentName:"h4"},"areEqual(one: T, two: T): boolean")),(0,i.kt)("p",null,"Checks if two versions of state are the same. You do not need to override this if your state is immutable."),(0,i.kt)("h4",{id:"doesnt-need-to-emit-a-change"},"Doesn't Need to Emit a Change"),(0,i.kt)("p",null,"Note that any store that extends ",(0,i.kt)("inlineCode",{parentName:"p"},"ReduceStore")," does not need to manually emit changes in ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce()")," (you still can if you want to though). The state is compared before and after each dispatch and changes are emitted automatically. If you need to control this behavior (perhaps because your state is mutable) override ",(0,i.kt)("inlineCode",{parentName:"p"},"areEqual()"),"."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"container"},(0,i.kt)("inlineCode",{parentName:"h3"},"Container")),(0,i.kt)("h4",{id:"createbase-reactclass-options-object-reactclass"},(0,i.kt)("inlineCode",{parentName:"h4"},"create(base: ReactClass, options: ?Object): ReactClass")),(0,i.kt)("p",null,"Create is used to transform a react class into a container that updates its state when relevant stores change. The provided base class must have static methods ",(0,i.kt)("inlineCode",{parentName:"p"},"getStores()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"calculateState()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {Component} from 'react';\nimport {Container} from 'flux/utils';\n\nclass CounterContainer extends Component {\n  static getStores() {\n    return [CounterStore];\n  }\n\n  static calculateState(prevState) {\n    return {\n      counter: CounterStore.getState(),\n    };\n  }\n\n  render() {\n    return <CounterUI counter={this.state.counter} />;\n  }\n}\n\nconst container = Container.create(CounterContainer);\n")),(0,i.kt)("p",null,"Additional options may be provided when creating your container in order to control certain behaviors."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Containers are pure")," - By default containers are pure, meaning they will not re-render when their props and state do not change (as determined by ",(0,i.kt)("inlineCode",{parentName:"p"},"shallowEquals()"),"). To disable this behavior pass options ",(0,i.kt)("inlineCode",{parentName:"p"},"{pure: false}")," as the second argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"create()"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Containers cannot access props")," - By default containers are not able to access any props. This is both for performance reasons, and to ensure that containers are re-usable and props do not have to be threaded throughout a component tree. There are some valid situations in which you need to determine your state based on both props and a store's state. In those situations pass options ",(0,i.kt)("inlineCode",{parentName:"p"},"{withProps: true}")," as the second argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"create()"),". This will expose the components props as the second argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"calculateState()"),"."))),(0,i.kt)("p",null,"If you are unable to utilize react classes most of this functionality is also mirrored in a mixin. ",(0,i.kt)("inlineCode",{parentName:"p"},"import {Mixin} from 'flux/utils';")),(0,i.kt)("h2",{id:"using-flux-with-react-hooks"},"Using Flux with React Hooks"),(0,i.kt)("p",null,"React 16.8 introduced ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-intro.html"},"Hooks"),". Much of the functionality of Flux and Flux Utils can be reproduced using ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-reference.html#usecontext"},"useContext")," & ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-reference.html#usereducer"},"useReducer"),"."),(0,i.kt)("h2",{id:"existing-projects-with-storereducestore"},"Existing Projects with ",(0,i.kt)("inlineCode",{parentName:"h2"},"Store"),"/",(0,i.kt)("inlineCode",{parentName:"h2"},"ReduceStore")),(0,i.kt)("p",null,"If you have existing projects that need to continue using Flux Util's Stores, you can use the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Fieldscope/flux-hooks"},"flux-hooks")," package. Access the store using useFluxStore which provides an API similar to ",(0,i.kt)("a",{parentName:"p",href:"#container"},"Container"),"'s calculateState."))}m.isMDXComponent=!0}}]);